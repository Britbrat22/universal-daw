<!DOCTYPE html>
<html>
<head>
    <title>Audio Editor</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        canvas { border: 1px solid #ccc; cursor: crosshair; }
        .controls { margin: 10px 0; }
        button { margin: 5px; padding: 8px 16px; }
        input[type="range"] { width: 200px; }
        label { display: inline-block; width: 120px; }
    </style>
</head>
<body>
    <h1>Audio Editor</h1>
    
    <div class="controls">
        <input type="file" id="fileInput" accept="audio/*">
        <button onclick="playAll()">Play</button>
        <button onclick="stopPlayback()">Stop</button>
        <button onclick="undoLastEdit()">Undo</button>
    </div>
    
    <div class="controls">
        <button onclick="deleteSelection()">Delete Selection</button>
        <button onclick="fadeInSelection()">Fade In</button>
        <button onclick="fadeOutSelection()">Fade Out</button>
        <button onclick="applySelectedEffects()">Apply Effects</button>
    </div>
    
    <div class="controls">
        <label>Reverb: <input type="range" id="reverbAmount" min="0" max="100" value="0"></label>
        <label>Echo: <input type="range" id="echoAmount" min="0" max="100" value="0"></label>
        <label>Pitch: <input type="range" id="pitchShift" min="-12" max="12" value="0"></label>
    </div>
    
    <canvas id="waveform" width="800" height="200"></canvas>
    
    <div class="controls">
        <button onclick="exportWAV()">Export WAV</button>
    </div>

<script>
/* ===============================
   CORE AUDIO ENGINE (FIXED)
================================ */

let audioContext;
let originalAudioBuffer;
let editedAudioBuffer;
let playbackSource = null;

let selection = { start: 0, end: 0 };
let undoStack = [];
const UNDO_LIMIT = 20;

let canvas, ctx;
let isSelecting = false;
let selectionStartX = 0;

/* ===============================
   INIT
================================ */

async function initAudioSystem() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  
  // Initialize canvas
  canvas = document.getElementById('waveform');
  ctx = canvas.getContext('2d');
  
  // Setup canvas events
  canvas.addEventListener('mousedown', startSelection);
  canvas.addEventListener('mousemove', updateSelection);
  canvas.addEventListener('mouseup', endSelection);
  
  // Setup file input
  document.getElementById('fileInput').addEventListener('change', handleFileSelect);
}

/* ===============================
   SELECTION SYSTEM
================================ */

function startSelection(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  isSelecting = true;
  selectionStartX = x;
  
  // Convert pixel to time
  const duration = editedAudioBuffer ? editedAudioBuffer.duration : 0;
  selection.start = (x / canvas.width) * duration;
  selection.end = selection.start;
}

function updateSelection(e) {
  if (!isSelecting) return;
  
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  
  const duration = editedAudioBuffer ? editedAudioBuffer.duration : 0;
  const time = (x / canvas.width) * duration;
  
  selection.start = Math.min(time, selection.start);
  selection.end = Math.max(time, selection.start);
  
  displayWaveform(editedAudioBuffer);
}

function endSelection() {
  isSelecting = false;
}

/* ===============================
   UNDO SYSTEM
================================ */

function pushUndo() {
  undoStack.push(cloneBuffer(editedAudioBuffer));
  if (undoStack.length > UNDO_LIMIT) undoStack.shift();
}

function undoLastEdit() {
  if (!undoStack.length) return alert("Nothing to undo");
  editedAudioBuffer = undoStack.pop();
  displayWaveform(editedAudioBuffer);
}

/* ===============================
   BUFFER HELPERS
================================ */

function cloneBuffer(buffer) {
  if (!buffer) return null;
  const b = audioContext.createBuffer(
    buffer.numberOfChannels,
    buffer.length,
    buffer.sampleRate
  );
  for (let c = 0; c < buffer.numberOfChannels; c++) {
    b.getChannelData(c).set(buffer.getChannelData(c));
  }
  return b;
}

function extractSelection(buffer, start, end) {
  const sr = buffer.sampleRate;
  const s = Math.floor(start * sr);
  const e = Math.floor(end * sr);
  const len = Math.max(0, e - s);

  const out = audioContext.createBuffer(
    buffer.numberOfChannels,
    len,
    sr
  );

  for (let c = 0; c < buffer.numberOfChannels; c++) {
    out.getChannelData(c).set(
      buffer.getChannelData(c).slice(s, e)
    );
  }
  return out;
}

/* REAL replace (rebuilds buffer correctly) */
function replaceSelection(buffer, insert, start, end) {
  const sr = buffer.sampleRate;
  const s = Math.floor(start * sr);
  const e = Math.floor(end * sr);

  const newLen = buffer.length - (e - s) + insert.length;
  const out = audioContext.createBuffer(
    buffer.numberOfChannels,
    newLen,
    sr
  );

  for (let c = 0; c < buffer.numberOfChannels; c++) {
    const o = out.getChannelData(c);
    const b = buffer.getChannelData(c);
    const i = insert.getChannelData(c);

    o.set(b.slice(0, s), 0);
    o.set(i, s);
    o.set(b.slice(e), s + i.length);
  }
  return out;
}

/* ===============================
   OFFLINE EFFECT PIPELINE
================================ */

async function processOffline(buffer, buildGraph) {
  const ctx = new OfflineAudioContext(
    buffer.numberOfChannels,
    buffer.length,
    buffer.sampleRate
  );

  const src = ctx.createBufferSource();
  src.buffer = buffer;

  const last = buildGraph(ctx, src);
  last.connect(ctx.destination);
  src.start();

  return await ctx.startRendering();
}

/* ===============================
   EFFECT CHAIN
================================ */

async function applyEffectsChain(buffer, fx) {
  return processOffline(buffer, (ctx, src) => {
    let node = src;

    if (fx.pitch !== 0) {
      src.playbackRate.value = Math.pow(2, fx.pitch / 12);
    }

    if (fx.reverb > 0) {
      const convolver = ctx.createConvolver();
      convolver.buffer = makeImpulse(ctx, fx.reverb);
      node.connect(convolver);
      node = convolver;
    }

    if (fx.echo > 0) {
      const delay = ctx.createDelay();
      delay.delayTime.value = 0.25;
      const fb = ctx.createGain();
      fb.gain.value = fx.echo * 0.4;
      delay.connect(fb);
      fb.connect(delay);
      node.connect(delay);
      node = delay;
    }

    return node;
  });
}

function makeImpulse(ctx, amt) {
  const len = ctx.sampleRate * 2;
  const buf = ctx.createBuffer(2, len, ctx.sampleRate);
  for (let c = 0; c < 2; c++) {
    const d = buf.getChannelData(c);
    for (let i = 0; i < len; i++) {
      d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2) * amt;
    }
  }
  return buf;
}

/* ===============================
   EFFECT BUTTON
================================ */

async function applySelectedEffects() {
  if (!editedAudioBuffer) return alert("Load audio first");
  if (selection.start === selection.end) return alert("Select audio first");

  pushUndo();

  const sel = extractSelection(
    editedAudioBuffer,
    selection.start,
    selection.end
  );

  const processed = await applyEffectsChain(sel, {
    reverb: document.getElementById("reverbAmount").value / 100,
    echo: document.getElementById("echoAmount").value / 100,
    pitch: parseFloat(document.getElementById("pitchShift").value)
  });

  editedAudioBuffer = replaceSelection(
    editedAudioBuffer,
    processed,
    selection.start,
    selection.end
  );

  displayWaveform(editedAudioBuffer);
}

/* ===============================
   DELETE / FADE
================================ */

function deleteSelection() {
  if (!editedAudioBuffer) return alert("Load audio first");
  if (selection.start === selection.end) return;
  
  pushUndo();

  editedAudioBuffer = replaceSelection(
    editedAudioBuffer,
    audioContext.createBuffer(
      editedAudioBuffer.numberOfChannels,
      0,
      editedAudioBuffer.sampleRate
    ),
    selection.start,
    selection.end
  );
  displayWaveform(editedAudioBuffer);
}

function fade(type) {
  if (!editedAudioBuffer) return alert("Load audio first");
  if (selection.start === selection.end) return;
  
  pushUndo();
  const sr = editedAudioBuffer.sampleRate;
  const s = Math.floor(selection.start * sr);
  const e = Math.floor(selection.end * sr);
  const len = e - s;

  for (let c = 0; c < editedAudioBuffer.numberOfChannels; c++) {
    const d = editedAudioBuffer.getChannelData(c);
    for (let i = 0; i < len; i++) {
      const g = type === "in" ? i / len : 1 - i / len;
      d[s + i] *= g;
    }
  }
  displayWaveform(editedAudioBuffer);
}

function fadeInSelection() { fade("in"); }
function fadeOutSelection() { fade("out"); }

/* ===============================
   PLAYBACK
================================ */

function stopPlayback() {
  if (playbackSource) {
    playbackSource.stop();
    playbackSource = null;
  }
}

function playAll() {
  if (!editedAudioBuffer) return alert("Load audio first");
  
  stopPlayback();
  playbackSource = audioContext.createBufferSource();
  playbackSource.buffer = editedAudioBuffer;
  playbackSource.connect(audioContext.destination);
  playbackSource.start();
}

/* ===============================
   WAV EXPORT (FIXED)
================================ */

function audioBufferToWav(buffer) {
  const numCh = buffer.numberOfChannels;
  const len = buffer.length * numCh * 2;
  const ab = new ArrayBuffer(44 + len);
  const v = new DataView(ab);
  let p = 0;

  function w(s) { for (let i = 0; i < s.length; i++) v.setUint8(p++, s.charCodeAt(i)); }

  w("RIFF"); v.setUint32(p, 36 + len, true); p += 4;
  w("WAVEfmt "); v.setUint32(p, 16, true); p += 4;
  v.setUint16(p, 1, true); p += 2;
  v.setUint16(p, numCh, true); p += 2;
  v.setUint32(p, buffer.sampleRate, true); p += 4;
  v.setUint32(p, buffer.sampleRate * numCh * 2, true); p += 4;
  v.setUint16(p, numCh * 2, true); p += 2;
  v.setUint16(p, 16, true); p += 2;
  w("data"); v.setUint32(p, len, true); p += 4;

  for (let i = 0; i < buffer.length; i++) {
    for (let c = 0; c < numCh; c++) {
      v.setInt16(p, buffer.getChannelData(c)[i] * 0x7fff, true);
      p += 2;
    }
  }
  return new Blob([ab], { type: "audio/wav" });
}

function exportWAV() {
  if (!editedAudioBuffer) return alert("Load audio first");
  
  const blob = audioBufferToWav(editedAudioBuffer);
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'edited_audio.wav';
  a.click();
  URL.revokeObjectURL(url);
}

/* ===============================
   WAVEFORM DISPLAY
================================ */

function displayWaveform(buffer) {
  if (!buffer) return;
  
  const width = canvas.width;
  const height = canvas.height;
  
  ctx.clearRect(0, 0, width, height);
  
  const data = buffer.getChannelData(0);
  const step = Math.ceil(data.length / width);
  const amp = height / 2;
  
  ctx.fillStyle = '#f0f0f0';
  ctx.fillRect(0, 0, width, height);
  
  ctx.beginPath();
  ctx.moveTo(0, amp);
  
  for (let i = 0; i < width; i++) {
    let min = 1.0;
    let max = -1.0;
    
    for (let j = 0; j < step; j++) {
      const datum = data[(i * step) + j];
      if (datum < min) min = datum;
      if (datum > max) max = datum;
    }
    
    ctx.lineTo(i, (1 + min) * amp);
    ctx.lineTo(i, (1 + max) * amp);
  }
  
  ctx.strokeStyle = '#007bff';
  ctx.stroke();
  
  // Draw selection
  if (selection.start !== selection.end) {
    const duration = buffer.duration;
    const startX = (selection.start / duration) * width;
    const endX = (selection.end / duration) * width;
    
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.fillRect(startX, 0, endX - startX, height);
  }
}

/* ===============================
   FILE HANDLING
================================ */

async function handleFileSelect(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  await handleFileLoad(file);
}

async function handleFileLoad(file) {
  await initAudioSystem();
  const buf = await audioContext.decodeAudioData(await file.arrayBuffer());
  originalAudioBuffer = buf;
  editedAudioBuffer = cloneBuffer(buf);
  displayWaveform(editedAudioBuffer);
}

/* ===============================
   START
================================ */

window.addEventListener("load", initAudioSystem);
</script>
</body>
</html>
