<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>AI Editor ‚Äì Spectrogram + Echo-Paint</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
:root{--bg:#0b0b0b;--panel:#151515;--accent:#4ecdc4;--danger:#ff6b6b;--text:#fff;--sub:#aaa;--border:#222;}
*{box-sizing:border-box;margin:0;padding:0;font-family:system-ui,sans-serif;}
body{background:var(--bg);color:var(--text);height:100vh;display:flex;flex-direction:column;}
header{padding:12px;background:#161616;display:flex;justify-content:space-between;}
button{background:var(--accent);border:none;padding:6px 10px;border-radius:4px;font-weight:bold;color:#000;cursor:pointer;}
button.danger{background:var(--danger);}
main{display:flex;flex:1;overflow:hidden;}
aside{width:260px;background:var(--panel);padding:10px;overflow-y:auto;border-right:1px solid var(--border);}
section{margin-bottom:12px;}
h3{margin:6px 0;color:var(--accent);font-size:13px;}
label{font-size:11px;color:var(--sub);}
input[type=range]{width:100%;margin:3px 0;}
.editor{flex:1;padding:8px;display:flex;flex-direction:column;}
.canvas-wrap{position:relative;background:#000;border:1px solid var(--border);border-radius:4px;overflow:hidden;}
canvas{width:100%;height:150px;cursor:crosshair;}
#selection,#playhead{position:absolute;top:0;bottom:0;pointer-events:none;}
#selection{background:rgba(78,205,196,.25);border:1px solid var(--accent);display:none;}
#playhead{width:2px;background:#ff6b6b;display:none;}
#specCanvas{width:100%;height:120px;cursor:crosshair;}
.right{width:260px;background:var(--panel);padding:10px;border-left:1px solid var(--border);font-size:11px;}
.history{max-height:120px;overflow-y:auto;}
.ai-box{background:rgba(0,0,0,.3);padding:6px;border-radius:3px;margin-top:4px;}
footer{padding:6px;text-align:center;background:#161616;font-size:12px;color:var(--sub);}
.info{font-size:10px;color:#888;margin-top:4px;}
</style>
</head>
<body>

<header>
  <div>üéµ AI Editor ‚Äì Spectrogram + Echo-Paint</div>
  <div>
    <button onclick="openFile()">üìÅ Load</button>
    <button onclick="exportWav()">üíæ Export</button>
    <input type="file" id="file" accept="audio/*" hidden>
  </div>
</header>

<main>
<!-- LEFT -->
<aside>
  <section>
    <h3>Selection</h3>
    <button onclick="selectAll()">Select All</button>
    <button onclick="clearSelection()">Clear</button>
  </section>

  <section>
    <h3>Wind / Noise</h3>
    <button onclick="deleteSelection()">üóëÔ∏è Delete Selected</button>
    <div class="info">Select noisy area on waveform or spectrogram ‚Üí Delete</div>
  </section>

  <section>
    <h3>Echo Paint</h3>
    <label>Echo amount</label>
    <input id="echoAmt" type="range" min="0" max="100" value="30">
    <label>Delay ms</label>
    <input id="delayMs" type="range" min="20" max="500" value="120">
    <button onclick="toggleEchoPaint()">üé® Echo-Paint (hold Shift + drag)</button>
  </section>

  <section>
    <h3>Zoom</h3>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
    <button onclick="zoomReset()">Reset</button>
  </section>

  <section>
    <h3>Playback</h3>
    <button onclick="playSelection()">Play Selection</button>
    <button onclick="playAll()">Play All</button>
    <button onclick="stop()">Stop</button>
  </section>
</aside>

<!-- MIDDLE -->
<div class="editor">
  <!-- WAVEFORM -->
  <div class="canvas-wrap">
    <canvas id="wave"></canvas>
    <div id="selection"></div>
    <div id="playhead"></div>
  </div>
  <!-- SPECTROGRAM -->
  <div class="canvas-wrap">
    <canvas id="specCanvas"></canvas>
  </div>
</div>

<!-- RIGHT -->
<div class="right">
  <section>
    <h3>Before / After</h3>
    <button onclick="playBefore()">Before</button>
    <button onclick="playAfter()">After</button>
    <div id="compareInfo" class="ai-box">Load audio to compare</div>
  </section>

  <section>
    <h3>History</h3>
    <div id="history" class="history">No edits yet</div>
  </section>
</div>
</main>

<footer id="status">Load audio to begin</footer>

<script>
/* ==========  CORE  ========== */
let ctx, originalBuffer, editedBuffer, undoStack=[], source;
let selection={start:0,end:0,active:false};
let zoom=1, offset=0;               // pixels per sample
let echoPaint=false;                // shift-drag echo mode
const canvas=document.getElementById("wave"), selDiv=document.getElementById("selection"), playheadDiv=document.getElementById("playhead"), cctx=canvas.getContext("2d");
const specCanvas=document.getElementById("specCanvas"), sctx=specCanvas.getContext("2d");
function status(msg){document.getElementById("status").textContent=msg;}
function openFile(){document.getElementById("file").click();}
document.getElementById("file").onchange=async e=>{
  ctx=new AudioContext();
  const buf=await e.target.files[0].arrayBuffer();
  originalBuffer=await ctx.decodeAudioData(buf);
  editedBuffer=cloneBuffer(originalBuffer);
  drawWave(); drawSpectrogram();
  addHistory("Original loaded");
  status("Audio ready ‚Äì zoom / select / paint echo");
};
function cloneBuffer(b){
  const nb=ctx.createBuffer(b.numberOfChannels,b.length,b.sampleRate);
  for(let c=0;c<b.numberOfChannels;c++) nb.getChannelData(c).set(b.getChannelData(c));
  return nb;
}

/* ==========  DRAW  ========== */
function drawWave(){
  canvas.width=canvas.offsetWidth; canvas.height=150;
  const data=editedBuffer.getChannelData(0);
  const len=data.length;
  const step=Math.max(1,Math.floor(len/(canvas.width*zoom)));
  const startSample=Math.floor(offset*len);
  cctx.clearRect(0,0,canvas.width,canvas.height);
  cctx.fillStyle="#4ecdc4";
  for(let x=0;x<canvas.width;x++){
    let min=1,max=-1;
    const s=startSample+x*step*zoom;
    for(let j=0;j<step;j++){
      const v=data[Math.min(s+j,len-1)];
      if(v<min)min=v; if(v>max)max=v;
    }
    cctx.fillRect(x,(1+min)*75,1,Math.max(1,(max-min)*75));
  }
}
function drawSpectrogram(){
  specCanvas.width=specCanvas.offsetWidth; specCanvas.height=120;
  const data=editedBuffer.getChannelData(0);
  const len=data.length;
  const step=Math.max(1,Math.floor(len/(specCanvas.width*zoom)));
  const startSample=Math.floor(offset*len);
  const fftSize=2048;
  const analyser=ctx.createAnalyser(); analyser.fftSize=fftSize;
  const buffer=ctx.createBuffer(1,fftSize,ctx.sampleRate);
  const bufData=buffer.getChannelData(0);
  sctx.clearRect(0,0,specCanvas.width,specCanvas.height);
  for(let x=0;x<specCanvas.width;x++){
    const s=startSample+x*step*zoom;
    for(let i=0;i<fftSize;i++) bufData[i]=data[Math.min(s+i,len-1)];
    analyser.getFloatFrequencyData(bufData);
    for(let y=0;y<specCanvas.height;y++){
      const bin=Math.floor(y/specCanvas.height*(fftSize/2));
      const db=bufData[bin];
      const val=Math.max(0,Math.min(1,(db+140)/140));
      sctx.fillStyle=`hsl(${240-val*240},100%,${val*60}%)`;
      sctx.fillRect(x,specCanvas.height-y,1,1);
    }
  }
}

/* ==========  SELECTION  ========== */
canvas.onmousedown=specCanvas.onmousedown=startSel;
function startSel(e){
  const r=e.target.getBoundingClientRect();
  const x=e.clientX-r.left;
  if(e.shiftKey){echoPaint=true; startEchoPaint(x); return;}
  selection.start=pixToTime(x);
  selection.active=true;
}
window.onmousemove=e=>{
  if(!selection.active)return;
  const r=canvas.getBoundingClientRect();
  selection.end=pixToTime(e.clientX-r.left);
  updateSel();
};
window.onmouseup=()=>selection.active=false;
function pixToTime(x){
  const len=editedBuffer.length;
  const startSample=Math.floor(offset*len);
  return (startSample+x*zoom)/ctx.sampleRate;
}
function updateSel(){
  const d=editedBuffer.duration;
  const s=Math.min(selection.start,selection.end), e=Math.max(selection.start,selection.end);
  const startX=timeToPix(s), endX=timeToPix(e);
  selDiv.style.display="block";
  selDiv.style.left=startX+"px";
  selDiv.style.width=(endX-startX)+"px";
}
function timeToPix(t){
  const len=editedBuffer.length;
  const startSample=Math.floor(offset*len);
  return (t*ctx.sampleRate-startSample)/zoom;
}

/* ==========  ECHO PAINT  ========== */
let echoRect={};
function startEchoPaint(x){
  echoRect.startX=x; echoRect.startS=pixToTime(x);
}
specCanvas.onmousemove=e=>{
  if(!echoPaint)return;
  const r=specCanvas.getBoundingClientRect();
  echoRect.endX=e.clientX-r.left; echoRect.endS=pixToTime(echoRect.endX);
  drawWave(); drawSpectrogram();
  sctx.strokeStyle="#ff0"; sctx.lineWidth=2;
  sctx.strokeRect(echoRect.startX,0,echoRect.endX-echoRect.startX,specCanvas.height);
};
specCanvas.onmouseup=async()=>{
  if(!echoPaint)return;
  echoPaint=false;
  undoStack.push(cloneBuffer(editedBuffer));
  const amt=document.getElementById("echoAmt").value/100;
  const ms=document.getElementById("delayMs").value/1000;
  const buf=extract(echoRect.startS,echoRect.endS);
  const processed=await echoRegion(buf,amt,ms);
  editedBuffer=replace(processed,echoRect.startS,echoRect.endS);
  drawWave(); drawSpectrogram();
  addHistory("Echo painted");
};
async function echoRegion(buf,amt,ms){
  const off=new OfflineAudioContext(buf.numberOfChannels,buf.length,buf.sampleRate);
  const src=off.createBufferSource(); src.buffer=buf;
  const dry=off.createGain(); dry.gain.value=1-amt;
  const wet=off.createGain(); wet.gain.value=amt;
  const delay=off.createDelay(1); delay.delayTime.value=ms;
  const fb=off.createGain(); fb.gain.value=0.4;
  src.connect(dry);
  src.connect(delay); delay.connect(wet); delay.connect(fb); fb.connect(delay);
  dry.connect(off.destination); wet.connect(off.destination);
  src.start(0);
  return await off.startRendering();
}
function toggleEchoPaint(){echoPaint=false; status("Echo-paint: hold Shift + drag on spectrogram");}

/* ==========  ZOOM  ========== */
function zoomIn(){zoom=Math.min(zoom*1.5,100); drawWave(); drawSpectrogram();}
function zoomOut(){zoom=Math.max(zoom/1.5,1); drawWave(); drawSpectrogram();}
function zoomReset(){zoom=1; offset=0; drawWave(); drawSpectrogram();}
specCanvas.onwheel=e=>{e.preventDefault(); zoom*=e.deltaY<0?1.1:0.9; zoom=Math.max(1,Math.min(zoom,200)); drawWave(); drawSpectrogram();};

/* ==========  PLAYBACK  ========== */
function playSelection(){stop(); const b=extract(selection.start,selection.end); source=ctx.createBufferSource(); source.buffer=b; source.connect(ctx.destination); source.start();}
function playAll(){stop(); source=ctx.createBufferSource(); source.buffer=editedBuffer; source.connect(ctx.destination); source.start();}
function stop(){if(source)source.stop();}
function playBefore(){stop(); source=ctx.createBufferSource(); source.buffer=originalBuffer; source.connect(ctx.destination); source.start(); document.getElementById("compareInfo").textContent="Playing: original (before)";}
function playAfter(){stop(); source=ctx.createBufferSource(); source.buffer=editedBuffer; source.connect(ctx.destination); source.start(); document.getElementById("compareInfo").textContent="Playing: edited (after)";}

/* ==========  DELETE  ========== */
async function deleteSelection(){
  if(selection.start===selection.end){alert("Select a region");return;}
  undoStack.push(cloneBuffer(editedBuffer));
  editedBuffer=replace(ctx.createBuffer(editedBuffer.numberOfChannels,0,editedBuffer.sampleRate),selection.start,selection.end);
  drawWave(); drawSpectrogram();
  addHistory("Deleted selected region");
}

/* ==========  HISTORY / EXPORT  ========== */
function addHistory(action){
  const box=document.getElementById("history");
  const entry=document.createElement("div");
  entry.style.cssText="background:rgba(78,205,196,.1);padding:4px;margin:4px 0;border-radius:4px;font-size:11px;";
  entry.innerHTML=`${action}<br><small style="color:#888">${new Date().toLocaleTimeString()}</small>`;
  box.insertBefore(entry,box.firstChild);
  while(box.children.length>10)box.removeChild(box.lastChild);
}
function exportWav(){
  const blob=bufferToWav(editedBuffer);
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="edited.wav";
  a.click();
}
function bufferToWav(b){
  const len=b.length*b.numberOfChannels*2+44, buf=new ArrayBuffer(len), v=new DataView(buf); let p=0;
  const w=s=>{for(let i=0;i<s.length;i++)v.setUint8(p++,s.charCodeAt(0));};
  w("RIFF");v.setUint32(p,36+b.length*2,true);p+=4;w("WAVEfmt ");v.setUint32(p,16,true);p+=4;
  v.setUint16(p,1,true);p+=2;v.setUint16(p,b.numberOfChannels,true);p+=2;v.setUint32(p,b.sampleRate,true);p+=4;
  v.setUint32(p,b.sampleRate*b.numberOfChannels*2,true);p+=4;v.setUint16(p,b.numberOfChannels*2,true);p+=2;v.setUint16(p,16,true);p+=2;
  w("data");v.setUint32(p,b.length*2,true);p+=4;
  for(let i=0;i<b.length;i++)for(let c=0;c<b.numberOfChannels;c++){v.setInt16(p,Math.max(-1,Math.min(1,b.getChannelData(c)[i]))*0x7FFF,true);p+=2;}
  return new Blob([buf],{type:"audio/wav"});
}

/* ==========  INIT  ========== */
window.onload=()=>{addHistory("App ready"); status("Ready ‚Äì load audio ‚Üí zoom ‚Üí select ‚Üí paint echo / delete noise");};
</script>
</body>
</html>
