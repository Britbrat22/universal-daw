<!DOCTYPE html>
<html>
<head>
    <title>Audio Editor - Debug Version</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            background: #f0f0f0;
        }
        #debug {
            background: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 20px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }
        canvas { 
            border: 2px solid #007bff; 
            cursor: crosshair; 
            background: white;
            display: none;
        }
        .controls { 
            margin: 10px 0; 
            padding: 10px;
            background: white;
            border-radius: 5px;
        }
        button { 
            margin: 5px; 
            padding: 10px 20px; 
            font-size: 14px;
            cursor: pointer;
        }
        input[type="range"] { 
            width: 200px; 
            margin: 0 10px;
        }
        label { 
            display: inline-block; 
            width: 120px; 
            font-weight: bold;
        }
        .error { color: red; }
        .success { color: green; }
        .info { color: blue; }
    </style>
</head>
<body>
    <h1>Audio Editor - Debug Version</h1>
    
    <div id="debug">Debug console ready...</div>
    
    <div class="controls">
        <h3>Step 1: Click this button first!</h3>
        <button id="initButton" onclick="initializeAudio()">Initialize Audio System</button>
        <span id="initStatus"></span>
    </div>
    
    <div class="controls" id="fileControls" style="display:none;">
        <h3>Step 2: Load Audio File</h3>
        <input type="file" id="fileInput" accept="audio/*">
    </div>
    
    <div class="controls" id="playbackControls" style="display:none;">
        <h3>Step 3: Playback Controls</h3>
        <button onclick="playAll()">‚ñ∂ Play</button>
        <button onclick="stopPlayback()">‚èπ Stop</button>
        <button onclick="undoLastEdit()">‚Ü∂ Undo</button>
    </div>
    
    <div class="controls" id="editControls" style="display:none;">
        <h3>Step 4: Edit Controls</h3>
        <button onclick="deleteSelection()">üóë Delete Selection</button>
        <button onclick="fadeInSelection()">üìà Fade In</button>
        <button onclick="fadeOutSelection()">üìâ Fade Out</button>
        <button onclick="applySelectedEffects()">‚ú® Apply Effects</button>
    </div>
    
    <div class="controls" id="effectControls" style="display:none;">
        <h3>Step 5: Effects</h3>
        <label>Reverb: <input type="range" id="reverbAmount" min="0" max="100" value="0"></label><br>
        <label>Echo: <input type="range" id="echoAmount" min="0" max="100" value="0"></label><br>
        <label>Pitch: <input type="range" id="pitchShift" min="-12" max="12" value="0"></label>
    </div>
    
    <canvas id="waveform" width="800" height="200"></canvas>
    
    <div class="controls" id="exportControls" style="display:none;">
        <h3>Step 6: Export</h3>
        <button onclick="exportWAV()">üíæ Export WAV</button>
    </div>

<script>
// Debug logging function
function log(message, type = 'info') {
    const debug = document.getElementById('debug');
    const timestamp = new Date().toLocaleTimeString();
    const color = type === 'error' ? 'red' : type === 'success' ? 'green' : 'blue';
    debug.innerHTML += `<span style="color: ${color};">[${timestamp}] ${message}</span>\n`;
    debug.scrollTop = debug.scrollHeight;
    console.log(`[${timestamp}] ${message}`);
}

// Global variables
let audioContext;
let originalAudioBuffer;
let editedAudioBuffer;
let playbackSource = null;
let selection = { start: 0, end: 0 };
let undoStack = [];
const UNDO_LIMIT = 20;
let canvas, ctx;
let isSelecting = false;

// Initialize audio system with user interaction
async function initializeAudio() {
    try {
        log('Initializing audio system...');
        
        // Check if Web Audio API is supported
        if (!window.AudioContext && !window.webkitAudioContext) {
            throw new Error('Web Audio API not supported in this browser');
        }
        
        // Create audio context
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        log(`AudioContext created: ${audioContext.state}`, 'success');
        
        // Resume audio context if suspended (required by browsers)
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
            log(`AudioContext resumed: ${audioContext.state}`, 'success');
        }
        
        // Initialize canvas
        canvas = document.getElementById('waveform');
        ctx = canvas.getContext('2d');
        
        // Setup canvas events
        canvas.addEventListener('mousedown', startSelection);
        canvas.addEventListener('mousemove', updateSelection);
        canvas.addEventListener('mouseup', endSelection);
        
        // Show next controls
        document.getElementById('initButton').disabled = true;
        document.getElementById('initStatus').innerHTML = '<span class="success">‚úì Audio system initialized!</span>';
        document.getElementById('fileControls').style.display = 'block';
        
        log('Audio system initialized successfully!', 'success');
        
    } catch (error) {
        log(`Error initializing audio: ${error.message}`, 'error');
        document.getElementById('initStatus').innerHTML = '<span class="error">‚úó Failed to initialize</span>';
    }
}

// File selection handling
async function handleFileSelect(e) {
    try {
        const file = e.target.files[0];
        if (!file) return;
        
        log(`Loading file: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`);
        
        if (!audioContext) {
            throw new Error('Audio system not initialized. Click the initialize button first!');
        }
        
        const arrayBuffer = await file.arrayBuffer();
        log('File loaded into memory, decoding audio data...');
        
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        log(`Audio decoded successfully: ${audioBuffer.duration.toFixed(2)}s, ${audioBuffer.sampleRate}Hz, ${audioBuffer.numberOfChannels} channels`, 'success');
        
        originalAudioBuffer = audioBuffer;
        editedAudioBuffer = cloneBuffer(audioBuffer);
        
        displayWaveform(editedAudioBuffer);
        
        // Show all controls
        document.getElementById('playbackControls').style.display = 'block';
        document.getElementById('editControls').style.display = 'block';
        document.getElementById('effectControls').style.display = 'block';
        document.getElementById('exportControls').style.display = 'block';
        canvas.style.display = 'block';
        
    } catch (error) {
        log(`Error loading file: ${error.message}`, 'error');
    }
}

// Waveform display function
function displayWaveform(buffer) {
    if (!buffer) return;
    
    try {
        const width = canvas.width;
        const height = canvas.height;
        
        ctx.clearRect(0, 0, width, height);
        
        const data = buffer.getChannelData(0);
        const step = Math.ceil(data.length / width);
        const amp = height / 2;
        
        // Draw background
        ctx.fillStyle = '#f8f9fa';
        ctx.fillRect(0, 0, width, height);
        
        // Draw center line
        ctx.strokeStyle = '#dee2e6';
        ctx.beginPath();
        ctx.moveTo(0, amp);
        ctx.lineTo(width, amp);
        ctx.stroke();
        
        // Draw waveform
        ctx.beginPath();
        ctx.moveTo(0, amp);
        
        for (let i = 0; i < width; i++) {
            let min = 1.0;
            let max = -1.0;
            
            for (let j = 0; j < step; j++) {
                const datum = data[(i * step) + j];
                if (datum < min) min = datum;
                if (datum > max) max = datum;
            }
            
            ctx.lineTo(i, (1 + min) * amp);
            ctx.lineTo(i, (1 + max) * amp);
        }
        
        ctx.strokeStyle = '#007bff';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw selection
        if (selection.start !== selection.end) {
            const duration = buffer.duration;
            const startX = (selection.start / duration) * width;
            const endX = (selection.end / duration) * width;
            
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.fillRect(startX, 0, endX - startX, height);
        }
        
        log(`Waveform displayed: ${buffer.duration.toFixed(2)}s`);
        
    } catch (error) {
        log(`Error displaying waveform: ${error.message}`, 'error');
    }
}

// Selection system
function startSelection(e) {
    if (!editedAudioBuffer) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    isSelecting = true;
    
    const duration = editedAudioBuffer.duration;
    selection.start = (x / canvas.width) * duration;
    selection.end = selection.start;
    
    displayWaveform(editedAudioBuffer);
}

function updateSelection(e) {
    if (!isSelecting || !editedAudioBuffer) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    
    const duration = editedAudioBuffer.duration;
    const time = (x / canvas.width) * duration;
    
    selection.start = Math.min(time, selection.start);
    selection.end = Math.max(time, selection.start);
    
    displayWaveform(editedAudioBuffer);
}

function endSelection() {
    isSelecting = false;
    if (selection.start !== selection.end) {
        log(`Selection made: ${selection.start.toFixed(2)}s to ${selection.end.toFixed(2)}s`);
    }
}

// Buffer helpers
function cloneBuffer(buffer) {
    if (!buffer) return null;
    const b = audioContext.createBuffer(
        buffer.numberOfChannels,
        buffer.length,
        buffer.sampleRate
    );
    for (let c = 0; c < buffer.numberOfChannels; c++) {
        b.getChannelData(c).set(buffer.getChannelData(c));
    }
    return b;
}

function pushUndo() {
    if (!editedAudioBuffer) return;
    undoStack.push(cloneBuffer(editedAudioBuffer));
    if (undoStack.length > UNDO_LIMIT) undoStack.shift();
    log(`Undo stack: ${undoStack.length} items`);
}

// Playback functions
function stopPlayback() {
    if (playbackSource) {
        playbackSource.stop();
        playbackSource = null;
        log('Playback stopped');
    }
}

function playAll() {
    if (!editedAudioBuffer) {
        log('No audio loaded', 'error');
        return;
    }
    
    try {
        stopPlayback();
        playbackSource = audioContext.createBufferSource();
        playbackSource.buffer = editedAudioBuffer;
        playbackSource.connect(audioContext.destination);
        playbackSource.start();
        log(`Playing audio (${editedAudioBuffer.duration.toFixed(2)}s)`);
    } catch (error) {
        log(`Playback error: ${error.message}`, 'error');
    }
}

function undoLastEdit() {
    if (!undoStack.length) {
        log('Nothing to undo', 'error');
        return;
    }
    editedAudioBuffer = undoStack.pop();
    displayWaveform(editedAudioBuffer);
    log('Undo performed');
}

function deleteSelection() {
    if (!editedAudioBuffer) {
        log('No audio loaded', 'error');
        return;
    }
    if (selection.start === selection.end) {
        log('No selection made', 'error');
        return;
    }
    
    log('Delete selection not fully implemented yet', 'info');
}

function fadeInSelection() {
    log('Fade in not fully implemented yet', 'info');
}

function fadeOutSelection() {
    log('Fade out not fully implemented yet', 'info');
}

function applySelectedEffects() {
    log('Effects not fully implemented yet', 'info');
}

function exportWAV() {
    log('Export not fully implemented yet', 'info');
}

// Setup file input listener
document.getElementById('fileInput').addEventListener('change', handleFileSelect);

// Initial log
log('Page loaded. Click "Initialize Audio System" to start!', 'info');
</script>
</body>
</html>
