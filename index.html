<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>BandLab-Style AI DAW ‚Äì Upload Fixed</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
:root{--bg:#0b0b0b;--panel:#151515;--accent:#4ecdc4;--danger:#ff6b6b;--text:#fff;--sub:#aaa;--border:#222;}
*{box-sizing:border-box;margin:0;padding:0;font-family:system-ui,sans-serif;}
body{background:var(--bg);color:var(--text);height:100vh;display:flex;flex-direction:column;overflow:hidden;}
header{padding:8px;background:#161616;display:flex;flex-wrap:wrap;gap:6px;align-items:center;}
button{background:var(--accent);border:none;padding:6px 10px;border-radius:4px;color:#000;font-weight:bold;cursor:pointer;}
button.danger{background:var(--danger);}
main{display:flex;flex:1;overflow:hidden;}
.left{width:260px;background:var(--panel);padding:8px;overflow-y:auto;border-right:1px solid var(--border);}
.track-controls{background:rgba(0,0,0,.3);padding:6px;margin-bottom:6px;border-radius:4px;}
.track-controls h4{font-size:12px;margin-bottom:4px;color:var(--accent);}
.timeline-wrap{flex:1;display:flex;flex-direction:column;}
.timeline-header{height:30px;background:#161616;border-bottom:1px solid var(--border);position:relative;}
.timeline-ruler{position:absolute;height:100%;left:0;top:0;font-size:10px;color:#888;}
.timeline-body{flex:1;overflow:auto;}
.track-lane{height:80px;background:#111;border-bottom:1px solid #222;position:relative;}
.wave-canvas{width:100%;height:100%;cursor:pointer;}
.midi-canvas{width:100%;height:100%;cursor:pointer;background:#000;}
.playhead-line{position:absolute;top:0;bottom:0;width:2px;background:#ff6b6b;pointer-events:none;display:none;}
.drop-here{border:2px dashed #444;border-radius:6px;padding:20px;text-align:center;font-size:12px;color:#888;margin-bottom:8px;}
.fader{width:100%;margin:3px 0;}
.small{font-size:10px;color:#888;}
.history{max-height:100px;overflow-y:auto;font-size:10px;}
.piano-roll{height:120px;background:#000;border:1px solid #333;border-radius:4px;position:relative;overflow:hidden;}
.loop-lib{background:rgba(0,0,0,.3);padding:6px;border-radius:4px;font-size:10px;margin-top:4px;}
.chat-box{height:100px;background:#000;border:1px solid #333;border-radius:4px;font-size:10px;overflow-y:auto;padding:4px;}
.chat-input{width:100%;margin-top:4px;font-size:10px;padding:4px;border:1px solid #333;border-radius:4px;background:#111;color:#fff;}
</style>
</head>
<body>

<header>
  <div class="drop-here" id="dropZone">Drop audio / MIDI files here (or click)</div>
  <button onclick="playAll()">‚ñ∂Ô∏è Play</button>
  <button onclick="stopAll()">‚èπÔ∏è Stop</button>
  <button onclick="loopToggle()">üîÅ Loop</button>
  <button onclick="splitAtPlayhead()">‚úÇÔ∏è Split</button>
  <button onclick="copyClip()">üìã Copy</button>
  <button onclick="pasteClip()">üì• Paste</button>
  <button onclick="deleteClip()">üóëÔ∏è Delete</button>
  <button onclick="zoomIn()">Zoom In</button>
  <button onclick="zoomOut()">Zoom Out</button>
  <button onclick="exportMix()">üíæ Export Mix</button>
  <input type="file" id="fileInput" multiple accept="audio/*,.mid,.midi" hidden>
</header>

<main>
<!-- LEFT PANEL -->
<div class="left">
  <section>
    <h3>AI Tools</h3>
    <button onclick="aiBeatGen()">ü•Å Generate Beat</button>
    <button onclick="aiVocalClean()">üé§ Clean Vocals</button>
    <button onclick="aiAlignVocals()">üîó Align Vocals</button>
    <button onclick="aiWriteLyrics()">üìù AI Lyrics</button>
  </section>

  <section>
    <h3>MIDI / Piano</h3>
    <button onclick="addMidiTrack()">‚ûï Add MIDI Track</button>
    <div class="piano-roll" id="piano"></div>
  </section>

  <section>
    <h3>Loop Library</h3>
    <button onclick="addLoop('kick')">Kick</button>
    <button onclick="addLoop('hat')">Hat</button>
    <button onclick="addLoop('snare')">Snare</button>
    <div class="loop-lib" id="loopLib">Drop loops here</div>
  </section>

  <section>
    <h3>Master FX</h3>
    <label>Reverb</label><input class="fader" id="masterReverb" type="range" min="0" max="100" value="0">
    <label>Delay</label><input class="fader" id="masterDelay" type="range" min="0" max="100" value="0">
    <label>Compression</label><input class="fader" id="masterComp" type="range" min="0" max="100" value="0">
  </section>

  <section>
    <h3>Collab Chat</h3>
    <div class="chat-box" id="chatLog">Chat ready‚Ä¶</div>
    <input class="chat-input" id="chatInput" placeholder="Type message‚Ä¶" onkeypress="if(event.key==='Enter')sendChat()">
  </section>

  <section>
    <h3>History</h3>
    <div id="history" class="history">No edits yet</div>
    <button onclick="undoLast()">‚Ü∂ Undo</button>
  </section>
</div>

<!-- TIMELINE -->
<div class="timeline-wrap">
  <div class="timeline-header">
    <div class="timeline-ruler" id="ruler"></div>
    <div class="playhead-line" id="playhead"></div>
  </div>
  <div class="timeline-body" id="timeline"></div>
</div>
</main>

<footer id="status">Ready ‚Äì drop audio / MIDI files to start</footer>

<script>
/* ==========  GLOBALS  ========== */
const tracks=[];                     // {name,buffer,gain,pan,mute,solo,id,clips:[],type:'audio'|'midi',notes:[]}
let playhead=0, zoom=1, isPlaying=false, loop=false, masterGain, masterReverb, masterDelay, masterComp;
const ctx=new (window.AudioContext||window.webkitAudioContext)();
masterGain=ctx.createGain(); masterGain.connect(ctx.destination);
masterComp=ctx.createDynamicsCompressor(); masterComp.threshold.value=-24; masterComp.knee.value=40; masterComp.ratio.value=12; masterComp.attack.value=0; masterComp.release.value=0.25;
masterReverb=ctx.createConvolver(); masterDelay=ctx.createDelay(); buildImpulse();
masterGain.connect(masterComp); masterComp.connect(masterReverb); masterReverb.connect(masterDelay); masterDelay.connect(ctx.destination);

let clipboard=null; const undoStack=[];

/* ==========  DROP / FILE  ========== */
const dropZone=document.getElementById("dropZone"), fileInput=document.getElementById("fileInput");
dropZone.onclick=()=>fileInput.click();
dropZone.ondragover=e=>{e.preventDefault(); dropZone.style.borderColor="#4ecdc4";};
dropZone.ondrop=async e=>{
  e.preventDefault(); dropZone.style.borderColor="#444"; await addFiles([...e.dataTransfer.files]);
};
// ‚≠êÔ∏è FIX: make the picker actually call addFiles
fileInput.onchange=async e=>await addFiles([...e.target.files]);

async function addFiles(files){
  for(const f of files){
    const buf=await f.arrayBuffer();
    let audioBuf=null;
    if(f.name.endsWith(".mid")||f.name.endsWith(".midi")){
      audioBuf=await midiToNotes(buf);
      const id=Date.now()+Math.random();
      tracks.push({name:f.name,buffer:null,gain:ctx.createGain(),pan:ctx.createStereoPanner(),mute:false,solo:false,id,clips:[],type:"midi",notes:audioBuf});
      createMidiLane(id);
    }else{
      audioBuf=await ctx.decodeAudioData(buf);
      const id=Date.now()+Math.random();
      tracks.push({name:f.name,buffer:audioBuf,gain:ctx.createGain(),pan:ctx.createStereoPanner(),mute:false,solo:false,id,clips:[{start:0,end:audioBuf.duration,buffer:audioBuf}],type:"audio"});
      createTrackLane(id);
    }
    addHistory(`Added: ${f.name}`);
  }
  renderRuler();
  status(`${tracks.length} file(s) loaded`);
}

/* ==========  MIDI -> NOTES (stub)  ========== */
async function midiToNotes(buf){
  return [{pitch:60,velocity:100,start:0,end:0.5},{pitch:64,velocity:90,start:0.5,end:1},{pitch:67,velocity:80,start:1,end:1.5}];
}

/* ==========  AUDIO TRACK LANE  ========== */
function createTrackLane(id){
  const lane=document.createElement("div"); lane.className="track-lane"; lane.id=`lane-${id}`;
  const cvs=document.createElement("canvas"); cvs.className="wave-canvas"; cvs.id=`wave-${id}`;
  cvs.onclick=e=>placePlayhead(e,id);
  lane.appendChild(cvs); document.getElementById("timeline").appendChild(lane);
  drawTrackClips(id);
  createTrackControls(id);
}
function drawTrackClips(id){
  const tr=tracks.find(t=>t.id===id);
  if(tr.type==="audio"){
    const cvs=document.getElementById(`wave-${id}`);
    const ctx2=cvs.getContext("2d");
    cvs.width=cvs.offsetWidth; cvs.height=cvs.offsetHeight;
    ctx2.clearRect(0,0,cvs.width,cvs.height);
    const maxDur=getMaxDur();
    tr.clips.forEach(cl=>{
      const x=(cl.start/maxDur)*cvs.width*zoom;
      const w=(cl.end-cl.start)/maxDur*cvs.width*zoom;
      const data=cl.buffer.getChannelData(0);
      const step=Math.ceil(data.length/w);
      ctx2.fillStyle="#4ecdc4";
      for(let i=0;i<w;i++){
        let min=1,max=-1;
        for(let j=0;j<step;j++){
          const v=data[Math.min(i*step+j,data.length-1)];
          if(v<min)min=v; if(v>max)max=v;
        }
        ctx2.fillRect(x+i,(1+min)*cvs.height/2,1,Math.max(1,(max-min)*cvs.height/2));
      }
    });
  }
}

/* ==========  MIDI LANE  ========== */
function createMidiLane(id){
  const lane=document.createElement("div"); lane.className="track-lane"; lane.id=`lane-${id}`;
  const cvs=document.createElement("canvas"); cvs.className="midi-canvas"; cvs.id=`midi-${id}`;
  cvs.onclick=e=>addMidiNote(e,id);
  lane.appendChild(cvs); document.getElementById("timeline").appendChild(lane);
  drawMidiNotes(id);
  createTrackControls(id);
}
function drawMidiNotes(id){
  const tr=tracks.find(t=>t.id===id);
  const cvs=document.getElementById(`midi-${id}`);
  const ctx2=cvs.getContext("2d");
  cvs.width=cvs.offsetWidth; cvs.height=cvs.offsetHeight;
  ctx2.clearRect(0,0,cvs.width,cvs.height);
  const maxDur=getMaxDur();
  tr.notes.forEach(n=>{
    const x=(n.start/maxDur)*cvs.width*zoom;
    const w=(n.end-n.start)/maxDur*cvs.width*zoom;
    const y=cvs.height-(n.pitch-48)/(72-48)*cvs.height;
    ctx2.fillStyle=`hsl(${(n.pitch-48)*3},80%,50%)`;
    ctx2.fillRect(x,y,w,10);
  });
}
function addMidiNote(e,id){
  const cvs=e.target;
  const x=e.offsetX;
  const maxDur=getMaxDur();
  const start=x/cvs.width*maxDur/zoom;
  const pitch=Math.round(48+(1-e.offsetY/cvs.height)*(72-48));
  const tr=tracks.find(t=>t.id===id);
  tr.notes.push({pitch,velocity:100,start,start+0.5,end:start+0.5});
  drawMidiNotes(id);
  addHistory("Added MIDI note");
}

/* ==========  TRANSPORT  ========== */
let playInterval;
function playAll(){
  if(isPlaying)return;
  isPlaying=true;
  playInterval=setInterval(()=>{
    playhead+=0.01; // 10 ms steps
    updatePlayhead();
    if(loop && playhead>getMaxDur()) playhead=0;
  },10);
  tracks.forEach(playTrack);
  status("Playing");
}
function stopAll(){
  isPlaying=false; clearInterval(playInterval);
  tracks.forEach(t=>{if(t.source) t.source.stop();});
  playhead=0; updatePlayhead();
  status("Stopped");
}
function playTrack(tr){
  if(tr.mute||(tracks.some(x=>x.solo)&&!tr.solo)) return;
  if(tr.type==="audio"){
    tr.clips.forEach(cl=>{
      const src=ctx.createBufferSource();
      src.buffer=cl.buffer;
      src.connect(tr.gain); tr.gain.connect(tr.pan); tr.pan.connect(masterGain);
      src.start(ctx.currentTime,playhead-cl.start);
      tr.source=src;
    });
  }
  if(tr.type==="midi"){
    // simple sine synth per note
    tr.notes.forEach(n=>{
      if(n.start<=playhead&&n.end>playhead){
        const osc=ctx.createOscillator();
        const gain=ctx.createGain();
        osc.frequency.value=440*Math.pow(2,(n.pitch-69)/12);
        gain.gain.value=n.velocity/127*0.3;
        osc.connect(gain).connect(tr.gain); tr.gain.connect(tr.pan); tr.pan.connect(masterGain);
        osc.start(ctx.currentTime); osc.stop(ctx.currentTime+0.2);
      }
    });
  }
}
function updatePlayhead(){
  const ruler=document.getElementById("ruler");
  const maxDur=getMaxDur();
  const left=(playhead/maxDur)*ruler.offsetWidth;
  document.getElementById("playhead").style.left=left+"px";
}
function getMaxDur(){return tracks.reduce((max,t)=>{
  if(t.type==="audio") return Math.max(max,...t.clips.map(c=>c.end));
  if(t.type==="midi") return Math.max(max,...t.notes.map(n=>n.end));
  return max;
},0)||1;}
function loopToggle(){loop=!loop; status(loop?"Loop ON":"Loop OFF");}

/* ==========  EDIT  ========== */
let clipboard=null;
function splitAtPlayhead(){
  if(!tracks.length){alert("No track");return;}
  undoStack.push(JSON.parse(JSON.stringify(tracks)));
  const tr=tracks[0]; // demo: split first track
  const split=playhead;
  const newClips=[];
  tr.clips.forEach(cl=>{
    if(split<=cl.start||split>=cl.end) {newClips.push(cl); return;}
    const left=cl.buffer.slice(0,(split-cl.start)*ctx.sampleRate);
    const right=cl.buffer.slice((split-cl.start)*ctx.sampleRate,cl.buffer.length);
    newClips.push({start:cl.start,end:split,buffer:left},{start:split,end:cl.end,buffer:right});
  });
  tr.clips=newClips;
  drawTrackClips(tr.id);
  addHistory("Split at playhead");
}
function copyClip(){
  if(!tracks.length){alert("No clip");return;}
  const tr=tracks[0];
  clipboard=JSON.parse(JSON.stringify(tr.clips)); // deep clone buffers
  addHistory("Copied clip(s)");
}
function pasteClip(){
  if(!clipboard){alert("Nothing copied");return;}
  undoStack.push(JSON.parse(JSON.stringify(tracks)));
  const tr=tracks[0];
  clipboard.forEach(cl=>{
    const buf=cloneBuffer(cl.buffer);
    tr.clips.push({start:playhead,end:playhead+buf.duration,buffer:buf});
  });
  drawTrackClips(tr.id);
  addHistory("Pasted clip(s)");
}
function deleteClip(){
  if(!tracks.length){alert("No clip");return;}
  undoStack.push(JSON.parse(JSON.stringify(tracks)));
  const tr=tracks[0];
  tr.clips=tr.clips.filter(cl=>!(playhead>=cl.start&&playhead<=cl.end));
  drawTrackClips(tr.id);
  addHistory("Deleted clip(s)");
}

/* ==========  ZOOM  ========== */
function zoomIn(){zoom=Math.min(zoom*1.5,50); tracks.forEach(t=>{if(t.type==="audio")drawTrackClips(t.id); else drawMidiNotes(t.id);});}
function zoomOut(){zoom=Math.max(zoom/1.5,1); tracks.forEach(t=>{if(t.type==="audio")drawTrackClips(t.id); else drawMidiNotes(t.id);});}

/* ==========  TRACK CONTROLS  ========== */
function setTrackVolume(id,val){
  const tr=tracks.find(t=>t.id===id); tr.gain.gain.value=val/100;
}
function setTrackPan(id,val){
  const tr=tracks.find(t=>t.id===id); tr.pan.pan.value=val/100;
}
function toggleMute(id){
  const tr=tracks.find(t=>t.id===id); tr.mute=!tr.mute; status(tr.mute?"Muted":"Unmuted");
}
function toggleSolo(id){
  const tr=tracks.find(t=>t.id===id); tr.solo=!tr.solo; status(tr.solo?"Solo ON":"Solo OFF");
}
function deleteTrack(id){
  undoStack.push(JSON.parse(JSON.stringify(tracks)));
  const idx=tracks.findIndex(t=>t.id===id);
  tracks.splice(idx,1);
  document.getElementById(`lane-${id}`).remove();
  document.querySelectorAll(".track-controls")[idx+1].remove();
  addHistory("Deleted track");
}

/* ==========  AI FEATURES  ========== */
async function aiBeatGen(){
  const offline=new OfflineAudioContext(2,ctx.sampleRate*8,ctx.sampleRate);
  const buf=offline.createBuffer(2,ctx.sampleRate*8,ctx.sampleRate);
  const kick=makeKick(); const hat=makeHat();
  for(let bar=0;bar<4;bar++){
    for(let beat=0;beat<4;beat++){
      const start=(bar*4+beat)*ctx.sampleRate*0.5;
      playSample(offline,buf,kick,start);
      playSample(offline,buf,hat,start);
      playSample(offline,buf,hat,start+ctx.sampleRate*0.25);
    }
  }
  const beatBuffer=await offline.startRendering();
  const id=Date.now()+Math.random();
  tracks.push({name:"AI-Beat-120",buffer:beatBuffer,gain:ctx.createGain(),pan:ctx.createStereoPanner(),mute:false,solo:false,id,clips:[{start:0,end:beatBuffer.duration,buffer:beatBuffer}],type:"audio"});
  createTrackLane(id);
  addHistory("AI beat generated");
}
function makeKick(){
  const buf=ctx.createBuffer(1,ctx.sampleRate*0.15,ctx.sampleRate);
  const d=buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=Math.sin(2*Math.PI*60*i/ctx.sampleRate)*Math.exp(-i/500);
  return buf;
}
function makeHat(){
  const buf=ctx.createBuffer(1,ctx.sampleRate*0.05,ctx.sampleRate);
  const d=buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.exp(-i/200)*0.3;
  return buf;
}
function playSample(ctx,buffer,sample,offset){
  const src=ctx.createBufferSource(); src.buffer=sample;
  src.connect(buffer.getChannelData(0)); src.connect(buffer.getChannelData(1));
  src.start(offset);
}
async function aiVocalClean(){
  if(!tracks.length){alert("Load a vocal track first");return;}
  undoStack.push(JSON.parse(JSON.stringify(tracks)));
  const tr=tracks[0];
  const offline=new OfflineAudioContext(tr.buffer.numberOfChannels,tr.buffer.length,tr.buffer.sampleRate);
  const src=offline.createBufferSource(); src.buffer=tr.buffer;
  const hp=offline.createBiquadFilter(); hp.type="highpass"; hp.frequency.value=80;
  const lp=offline.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=9000;
  const highs=offline.createBiquadFilter(); highs.type="highshelf"; highs.frequency.value=4000; highs.gain.value=2;
  src.connect(hp).connect(lp).connect(highs).connect(offline.destination);
  src.start(0);
  tr.buffer=await offline.startRendering();
  tr.clips.forEach(cl=>cl.buffer=tr.buffer);
  drawTrackClips(tr.id);
  addHistory("AI vocal cleaned");
}
function aiAlignVocals(){if(tracks.length<2){alert("Need vocal + beat");return;} addHistory("AI alignment (demo)");}
function aiWriteLyrics(){
  const lines=["I'm walking on sunshine","Got clouds under my feet","AI wrote this rhyme in real-time","BandLab-style beat"];
  addHistory("AI lyrics: "+lines[0]);
  alert("AI Lyrics:\n"+lines.join("\n"));
}

/* ==========  LOOP LIBRARY  ========== */
const loopBank={kick:null,hat:null,snare:null};
async function addLoop(type){
  if(!loopBank[type]){
    if(type==="kick") loopBank.kick=makeKick();
    if(type==="hat") loopBank.hat=makeHat();
    if(type==="snare") loopBank.snare=makeSnare();
  }
  const buf=loopBank[type];
  const id=Date.now()+Math.random();
  tracks.push({name:`Loop-${type}`,buffer:buf,gain:ctx.createGain(),pan:ctx.createStereoPanner(),mute:false,solo:false,id,clips:[{start:playhead,end:playhead+buf.duration,buffer:buf}],type:"audio"});
  createTrackLane(id);
  addHistory(`Added loop: ${type}`);
}
function makeSnare(){
  const buf=ctx.createBuffer(1,ctx.sampleRate*0.2,ctx.sampleRate);
  const d=buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.exp(-i/1000)*0.5;
  return buf;
}

/* ==========  COLLAB CHAT  ========== */
function sendChat(){
  const inp=document.getElementById("chatInput");
  const log=document.getElementById("chatLog");
  const msg=inp.value.trim(); if(!msg)return;
  log.innerHTML+=`<div><b>You:</b> ${msg}</div>`;
  // stub: broadcast via WebRTC or WebSocket
  setTimeout(()=>{log.innerHTML+=`<div><b>Collab:</b> Got it üëç</div>`; log.scrollTop=log.scrollHeight;},500);
  inp.value="";
}

/* ==========  MASTER FX KNOBS  ========== */
document.getElementById("masterReverb").oninput=e=>masterReverb.gain.value=e.target.value/100;
document.getElementById("masterDelay").oninput=e=>masterDelay.delayTime.value=e.target.value/500;
document.getElementById("masterComp").oninput=e=>masterComp.threshold.value=-40+e.target.value/2;

/* ==========  IMPULSE / EXPORT  ========== */
function buildImpulse(){
  const len=ctx.sampleRate*2; const impulse=ctx.createBuffer(2,len,ctx.sampleRate);
  for(let c=0;c<2;c++){const d=impulse.getChannelData(c);for(let i=0;i<len;i++)d[i]=(Math.random()*2-1)*(1-i/len);}
  masterReverb.buffer=impulse;
}
async function exportMix(){
  if(!tracks.length){alert("Nothing to export");return;}
  const maxLen=Math.max(...tracks.map(t=>{
    if(t.type==="audio") return Math.max(...t.clips.map(c=>c.end*ctx.sampleRate));
    if(t.type==="midi") return Math.max(...t.notes.map(n=>n.end*ctx.sampleRate));
    return 0;
  }),0);
  const offline=new OfflineAudioContext(2,maxLen,ctx.sampleRate);
  // rebuild master chain offline
  const offGain=offline.createGain(); const offComp=offline.createDynamicsCompressor(); offComp.threshold.value=masterComp.threshold.value;
  const offRev=offline.createConvolver(); offRev.buffer=masterReverb.buffer;
  const offDel=offline.createDelay(1); offDel.delayTime.value=masterDelay.delayTime.value;
  offGain.connect(offComp); offComp.connect(offRev); offRev.connect(offDel); offDel.connect(offline.destination);
  tracks.forEach(t=>{
    if(t.mute||(tracks.some(x=>x.solo)&&!t.solo))return;
    if(t.type==="audio"){
      t.clips.forEach(cl=>{
        const src=offline.createBufferSource(); src.buffer=cl.buffer;
        const g=offline.createGain(); g.gain.value=70/100;
        const p=offline.createStereoPanner(); p.pan.value=t.pan.pan.value;
        src.connect(g).connect(p).connect(offGain);
        src.start(cl.start);
      });
    }
    if(t.type==="midi"){
      t.notes.forEach(n=>{
        const osc=offline.createOscillator();
        const gain=offline.createGain();
        osc.frequency.value=440*Math.pow(2,(n.pitch-69)/12);
        gain.gain.value=n.velocity/127*0.3;
        osc.connect(gain).connect(offGain);
        osc.start(n.start); osc.stop(n.end);
      });
    }
  });
  const buffer=await offline.startRendering();
  const blob=bufferToWav(buffer);
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="mixdown.wav"; a.click();
  addHistory("Exported mix");
}
function bufferToWav(buffer){
  const len=buffer.length*buffer.numberOfChannels*2+44, buf=new ArrayBuffer(len), v=new DataView(buf); let p=0;
  const w=s=>{for(let i=0;i<s.length;i++)v.setUint8(p++,s.charCodeAt(0));};
  w("RIFF");v.setUint32(p,36+buffer.length*2,true);p+=4;w("WAVEfmt ");v.setUint32(p,16,true);p+=4;
  v.setUint16(p,1,true);p+=2;v.setUint16(p,buffer.numberOfChannels,true);p+=2;v.setUint32(p,buffer.sampleRate,true);p+=4;
  v.setUint32(p,buffer.sampleRate*buffer.numberOfChannels*2,true);p+=4;v.setUint16(p,buffer.numberOfChannels*2,true);p+=2;v.setUint16(p,16,true);p+=2;
  w("data");v.setUint32(p,buffer.length*2,true);p+=4;
  for(let i=0;i<buffer.length;i++)for(let c=0;c<buffer.numberOfChannels;c++){v.setInt16(p,Math.max(-1,Math.min(1,buffer.getChannelData(c)[i]))*0x7FFF,true);p+=2;}
  return new Blob([buf],{type:"audio/wav"});
}

/* ==========  UNDO  ========== */
function undoLast(){
  if(!undoStack.length){alert("Nothing to undo");return;}
  const prev=undoStack.pop();
  // rebuild entire track list
  document.querySelectorAll(".track-lane").forEach(l=>l.remove());
  document.querySelectorAll(".track-controls").forEach(c=>c.remove());
  tracks.length=0;
  prev.forEach(t=>{
    tracks.push({...t,gain:ctx.createGain(),pan:ctx.createStereoPanner(),clips:t.clips? t.clips.map(c=>({...c,buffer:cloneBuffer(c.buffer)})): [],notes:t.notes? t.notes.map(n=>({...n})): []});
    if(t.type==="audio") createTrackLane(t.id);
    if(t.type==="midi") createMidiLane(t.id);
  });
  addHistory("Undo last action");
}
function cloneBuffer(b){
  const nb=ctx.createBuffer(b.numberOfChannels,b.length,b.sampleRate);
  for(let c=0;c<b.numberOfChannels;c++) nb.getChannelData(c).set(b.getChannelData(c));
  return nb;
}

/* ==========  INIT  ========== */
buildImpulse();
window.onload=()=>{addHistory("App ready"); status("Drop audio / MIDI files to start");};
</script>
</body>
</html>
